use crate::Parser::ast::*;
use crate::Lexer::lexer::Token;
use crate::Semantic::ts::*;
use crate::Lexer::error::CustomError;
use crate::SymbolTable;
use std::process::exit;

//grammar(text: &str);
grammar(text: &str);

pub Program: Program = {
    "VAR_GLOBAL" "{" <g:VarGlobalBlock?> "}"
    "DECLARATION" "{" <d:DeclarationBlock?> "}"
    "INSTRUCTION" "{" <i:InstructionBlock?> "}" => {
        Program::new(g, d, i)
    }
};

VarGlobalBlock: Vec<Declaration> = {
    Declaration+ => <>,
};

DeclarationBlock: Vec<Declaration> = {
    Declaration+ => <>,
};

InstructionBlock: Vec<Instruction> = {
    Instruction+ => <>,
};

Declaration: Declaration = {
    <t:Type> <v:VarList> ";" => {
        let rust_type = match t {
            Type::Integer => Types::Integer,
            Type::Float => Types::Float,
            Type::Char => Types::Char,
        };
        
        for var in &v {
            // let mut table = SymbolTable.lock().unwrap();
            match var {
                Variable::Simple(name) => {
                    let Identifier = name.clone();
                    match insert(&SymbolTable, Symbol::new(Identifier, Some(rust_type.clone()), Some(false), None, None, None)) {
                        Ok(t) => {},
                        Err(s) => panic!("{}", s),
                    }
                },
                Variable::Initialized(name, expr) => {
                    let Identifier = name.clone();
                    match insert(&SymbolTable, Symbol::new(Identifier, Some(rust_type.clone()), Some(false), None, None, None)) {
                        Ok(t) => {},
                        Err(s) => {
                            eprintln!("Syntactic Error: {}", s);
                            exit(1);
                        },
                    }
                }
            }
        }
        Declaration::Variables(t, v)
    },

    <t: Type> <a: ArrayDeclarationList> ";" => {
        let rust_type = match t {
            Type::Integer => Types::Integer,
            Type::Float => Types::Float,
            Type::Char => Types::Char,
        };

        for var in &a {
            // let mut table = SymbolTable.lock().unwrap();
            match var {
                ArrayDecl::Simple(Identifier, Size) => {
                    let Identifier = Identifier.clone();
                    match insert(&SymbolTable, Symbol::new(Identifier, Some(rust_type.clone()), Some(false), None, None, None)) {
                        Ok(t) => {},
                        Err(s) => {
                            eprintln!("Syntactic Error: {}", s);
                            exit(1);
                        },
                    }
                },
                ArrayDecl::Initialized(Identifier, Size, Value) => {
                    let Identifier = Identifier.clone();
                    match insert(&SymbolTable, Symbol::new(Identifier, Some(rust_type.clone()), Some(false), None, None, None)) {
                        Ok(t) => {},
                        Err(s) => {
                            eprintln!("Syntactic Error: {}", s);
                            exit(1);
                        },
                    }
                },

                ArrayDecl::InitializedString(Identifier, Size, Value) => {
                    let Identifier = Identifier.clone();
                    let symbolTableValue;
                    if Value.chars().count() == 0 {
                        symbolTableValue = Some(TypeValue::Char('\0'));
                    }
                    else {
                    // Set initial value to first character (here it's second because first is double quote)
                        symbolTableValue = Some(TypeValue::Char(Value.chars().nth(1).unwrap()));
                    }
                    match insert(&SymbolTable, Symbol::new(Identifier, Some(rust_type.clone()), Some(false), None, symbolTableValue, None)) {
                        Ok(t) => {},
                        Err(s) => {
                            eprintln!("Syntactic Error: {}", s);
                            exit(1);
                        },
                    }
                }
            }
        }

        Declaration::Array(t, a)
    },

    "CONST" <t:Type> <a:AssignList> ";" => {
        let rust_type = match t {
            Type::Integer => Types::Integer,
            Type::Float => Types::Float,
            Type::Char => Types::Char,
        };
        
        for assign in &a {
            let Identifier = assign.var.clone(); 
            match insert(&SymbolTable, Symbol::new(Identifier, Some(rust_type.clone()), Some(true), None, None, None)) {
                Ok(t) => {},
                Err(s) => {
                    eprintln!("Syntactic Error: {}", s);
                    exit(1);
                },
            }
        }
        Declaration::Constant(t, a)
    },
};

Type: Type = {
    "INTEGER" => Type::Integer,
    "FLOAT" => Type::Float,
    "CHAR" => Type::Char,
};

VarList: Vec<Variable> = {
    SimpleVar => vec![<>],
    <v:SimpleVar> "," <mut vs:VarList> => {
        vs.insert(0, v);
        vs
    },
};

SimpleVar: Variable = {
    <i:"Identifier"> => Variable::Simple(i.parse().unwrap()),
    <v:"Identifier"> "=" <e:Expr> => Variable::Initialized(v.parse().unwrap(), e),
};

ArrayDeclarationList: Vec<ArrayDecl> = {
    ArrayDecl => vec![<>],
    <a: ArrayDecl> "," <mut as_: ArrayDeclarationList> => {
        as_.insert(0, a);
        as_
    }
};

ArrayDecl: ArrayDecl = {
    <i:"Identifier"> "[" <s: Expr> "]" => {
        ArrayDecl::Simple(i, s)
    },
    <i:"Identifier"> "[" <s: Expr> "]" "=" "[" <v: ExpressionList> "]" => {
        ArrayDecl::Initialized(i, s, v)
    },
    <i:"Identifier"> "[" <s: Expr> "]" "=" <v: StringLit> => {
        ArrayDecl::InitializedString(i, s, v)
    },
};

ExpressionList: Vec<Expr> = {
    Expr => vec![<>],
    <a: Expr> "," <mut as_: ExpressionList> => {
        as_.insert(0, a);
        as_
    }
};

AssignList: Vec<Assignment> = {
    Assignment => vec![<>],
    <a:Assignment> "," <mut as_:AssignList> => {
        as_.insert(0, a);
        as_
    }
};

Assignment: Assignment = {
    <v:"Identifier"> "=" <e:Expr> => {
        Assignment::new(v, None, e)
    },
    <v:"Identifier"> "[" <index: Expr> "]" "=" <e:Expr> => {
        Assignment::new(v, Some(index), e)
    },
};

Instruction: Instruction = {
    <a:Assignment> ";" => Instruction::Assign(a),
    <i:IfStatement> => Instruction::If(i),
    <f:ForLoop> => Instruction::For(f),
    <r:ReadStatement> => Instruction::Read(r),
    <w:WriteStatement> => Instruction::Write(w),
};

Expr: Expr = {
    Term => <>,
    <l:Expr> "+" <r:Term> => Expr::BinaryOp(Box::new(l), BinOp::Add, Box::new(r)),
    <l:Expr> "-" <r:Term> => Expr::BinaryOp(Box::new(l), BinOp::Sub, Box::new(r)),
};

Term: Expr = {
    Factor => <>,
    <l:Term> "*" <r:Factor> => Expr::BinaryOp(Box::new(l), BinOp::Mul, Box::new(r)),
    <l:Term> "/" <r:Factor> => Expr::BinaryOp(Box::new(l), BinOp::Div, Box::new(r)),
};

Factor: Expr = {
    "(" <Expr> ")" => <>,
    <i:"Identifier"> => {
        Expr::Variable(i)
    },
    <i: "Identifier"> "[" <index: Expr> "]" => Expr::Array(i, Box::new(index)),
    <n: "Integer"> => Expr::Literal(TypeValue::Integer(n)),
    <f: "Float"> => Expr::Literal(TypeValue::Float(f)),
    <c: "Char"> => Expr::Literal(TypeValue::Char(c)),
};

IfStatement: IfStmt = {
    "IF" "(" <c:Condition> ")" "{" <t:InstructionBlock> "}" <e:ElseBlock?> =>
        IfStmt::new(c, t, e),
};

ElseBlock: Vec<Instruction> = {
    "ELSE" "{" <i:InstructionBlock> "}" => i,
};

Condition: Condition = {
    OrCondition => <>,
};

OrCondition: Condition = {
    AndCondition => <>,
    <l:OrCondition> "||" <r:AndCondition> => 
        Condition::Logic(Box::new(l), LogOp::Or, Box::new(r)),
};

AndCondition: Condition = {
    NotCondition => <>,
    <l:AndCondition> "&&" <r:NotCondition> =>
        Condition::Logic(Box::new(l), LogOp::And, Box::new(r)),
};

NotCondition: Condition = {
    BaseCondition => <>,
    "!" <c:NotCondition> => Condition::Not(Box::new(c)),
};

BaseCondition: Condition = {
    "(" <Condition> ")" => <>,
    BasicCondition => Condition::Basic(<>),
};

BasicCondition: BasicCond = {
    <l:Expr> <op:RelOp> <r:Expr> => BasicCond::new(l, op, r),
};

RelOp: RelOp = {
    ">" => RelOp::Gt,
    "<" => RelOp::Lt,
    ">=" => RelOp::Ge,
    "<=" => RelOp::Le,
    "==" => RelOp::Eq,
    "!=" => RelOp::Ne,
};

ForLoop: ForStmt = {
    "FOR" "(" <i:Assignment> ":" <s:Expr> ":" <c:Expr> ")" "{" <b:InstructionBlock> "}" =>
        ForStmt::new(i, s, c, b),
};

ReadStatement: ReadStmt = {
    "READ" "(" <i:Identifier> ")" ";" => {
        ReadStmt::new(i)
    }
};

WriteStatement: WriteStmt = {
    "WRITE" "(" <e:WriteElementList> ")" ";" => WriteStmt::new(e),
};

WriteElementList: Vec<WriteElement> = {
    WriteElement => vec![<>],
    <e:WriteElement> "," <mut es:WriteElementList> => {
        es.insert(0, e);
        es
    }
};

WriteElement: WriteElement = {
    StringLit => WriteElement::String(<>),
    <i:"Identifier"> => WriteElement::Variable(i.parse().unwrap())
};

Identifier: String = {
    <s:"Identifier"> => String::from(s),
};

StringLit: String = {
    <s:"StringLiteral"> => String::from(s),
};

extern {
    type Location = usize;
    type Error = CustomError;

    enum Token {
        "VAR_GLOBAL" => Token::VarGlobal,
        "DECLARATION" => Token::Declaration,
        "INSTRUCTION" => Token::Instruction,
        "CONST" => Token::Const,
        "READ" => Token::Read,
        "WRITE" => Token::Write,
        "IF" => Token::If,
        "ELSE" => Token::Else,
        "FOR" => Token::For,
        "INTEGER" => Token::IntegerType,
        "FLOAT" => Token::FloatType,
        "CHAR" => Token::CharType,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Multiply,
        "/" => Token::Divide,
        "&&" => Token::And,
        "||" => Token::Or,
        "!" => Token::Not,
        ">" => Token::GreaterThan,
        "<" => Token::LessThan,
        ">=" => Token::GreaterEqual,
        "<=" => Token::LessEqual,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "=" => Token::Assign,
        ";" => Token::Semicolon,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "(" => Token::OpenParen,
        ")" => Token::CloseParen,
        "," => Token::Comma,
        ":" => Token::Colon,
        "[" => Token::OpenBracket,
        "]" => Token::CloseBracket,
        "Identifier" => Token::Identifier(<String>),
        "Integer" => Token::Integer(<i16>),
        "Float" => Token::Float(<f32>),
        "Char" => Token::Char(<char>),
        "StringLiteral" => Token::StringLiteral(<String>),
    }
}